<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Planet System</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 300;
            background: linear-gradient(90deg, #fff, #a8ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        p {
            margin-top: 5px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1rem;
            z-index: 10;
            line-height: 1.8;
            background: rgba(0,0,0,0.6);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            min-width: 250px;
        }
        .control-icon {
            font-size: 1.2rem;
            margin-right: 8px;
            vertical-align: middle;
        }
        /* Hand Control UI */
        #cam-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
        }
        button.btn-glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        button.btn-glass:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 100, 255, 0.3);
        }
        button.active {
            background: rgba(0, 150, 255, 0.4);
            border-color: rgba(0, 150, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.3);
        }
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            opacity: 0; /* Hidden by default */
            transform: scaleX(-1); /* Mirror */
            transition: opacity 0.5s;
            z-index: 5;
            background: #000;
            object-fit: cover;
        }
        /* Virtual Hand Cursor */
        #hand-cursor {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(0, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            z-index: 100;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
            transition: top 0.1s, left 0.1s; /* Smooth movement */
        }
        .mode-badge {
            font-size: 0.9rem;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            border-radius: 20px;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
            text-align: right;
            transition: all 0.3s ease;
        }
        .mode-active {
            border-color: #00ffff;
            color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <h1>Celestial Viewer</h1>
        <p>Procedural Planet & Nebula System</p>
    </div>

    <div id="cam-controls">
        <button id="btn-toggle-cam" class="btn-glass">Start Hand Control</button>
        <div id="hand-status" class="mode-badge" style="display:none;">Waiting for hands...</div>
    </div>

    <div class="controls-info" id="instructions">
        <div style="margin-bottom:8px; color: #888; font-size: 0.8rem; text-transform: uppercase;">Instructions</div>
        <div><span class="control-icon">üëã</span> <b>ONE HAND:</b> Move to <b>ROTATE</b></div>
        <div style="margin-top:5px;"><span class="control-icon">üëê</span> <b>TWO HANDS:</b> Move apart to <b>ZOOM</b></div>
    </div>

    <video id="webcam-feed" playsinline></video>
    <div id="hand-cursor"></div>
    <div id="canvas-container"></div>

    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            planetRadius: 5,
            ringInnerRadius: 7,
            ringOuterRadius: 12,
            starCount: 5000,
            dustCount: 2000,
            rotationSpeed: 0.0005
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015); // Darker fog for deep space

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 15, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 8;
        controls.maxDistance = 100;

        // --- Texture Generators ---
        function createPlanetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a2b4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < 60; i++) {
                const y = Math.random() * canvas.height;
                const height = Math.random() * 40 + 5;
                const colors = ['#2c4f7a', '#4a8bba', '#85c1e9', '#153152', '#0a1a2e', '#4b2e52'];
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.globalAlpha = Math.random() * 0.5 + 0.2;
                ctx.fillRect(0, y, canvas.width, height);
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0.0, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.2, 'rgba(168, 204, 255, 0.1)');
            gradient.addColorStop(0.4, 'rgba(168, 204, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.55, 'rgba(120, 160, 200, 0.6)');
            gradient.addColorStop(0.9, 'rgba(200, 220, 255, 0.3)');
            gradient.addColorStop(1.0, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const tex = new THREE.CanvasTexture(canvas);
            tex.rotation = -Math.PI / 2;
            tex.center.set(0.5, 0.5);
            return tex;
        }

        // --- Celestial Objects ---
        const planet = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.planetRadius, 64, 64),
            new THREE.MeshStandardMaterial({ map: createPlanetTexture(), roughness: 0.7, metalness: 0.2 })
        );
        scene.add(planet);

        const atmosphere = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.planetRadius + 0.2, 64, 64),
            new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                        gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            })
        );
        scene.add(atmosphere);

        const rings = new THREE.Mesh(
            new THREE.RingGeometry(CONFIG.ringInnerRadius, CONFIG.ringOuterRadius, 128),
            new THREE.MeshStandardMaterial({ 
                color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8, map: createRingTexture() 
            })
        );
        rings.rotation.x = -Math.PI / 2;
        scene.add(rings);

        // --- ENHANCED PARTICLE SYSTEM ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<CONFIG.starCount; i++) {
            starPos.push((Math.random()-0.5)*400, (Math.random()-0.5)*400, (Math.random()-0.5)*400);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(
            starGeo, 
            new THREE.PointsMaterial({ color: 0x888888, size: 0.15 })
        );
        scene.add(stars);

        const dustGeo = new THREE.BufferGeometry();
        const dustPos = [];
        const dustCols = [];
        const colorPalette = [new THREE.Color('#00ffff'), new THREE.Color('#ff00ff'), new THREE.Color('#4466ff')];
        for(let i=0; i<CONFIG.dustCount; i++) {
            const r = 20 + Math.random() * 60;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            dustPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            const col = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            dustCols.push(col.r, col.g, col.b);
        }
        dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
        dustGeo.setAttribute('color', new THREE.Float32BufferAttribute(dustCols, 3));
        const dust = new THREE.Points(dustGeo, new THREE.PointsMaterial({
            size: 0.4, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        scene.add(dust);

        // --- Lighting ---
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(50, 20, 30);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        // --- SIMPLIFIED GESTURE CONTROL LOGIC ---
        let handActive = false;
        let previousTwoHandDist = null;
        
        const videoElement = document.getElementById('webcam-feed');
        const cursorElement = document.getElementById('hand-cursor');
        const statusElement = document.getElementById('hand-status');
        const toggleBtn = document.getElementById('btn-toggle-cam');
        
        let handX = 0.5; // Normalized 0-1
        let handY = 0.5;

        async function onResults(results) {
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;

            if (handCount > 0) {
                handActive = true;
                statusElement.classList.add('mode-active');
                
                if (handCount === 2) {
                    // --- TWO HANDS: ZOOM MODE ---
                    statusElement.innerHTML = "üëê <b>ZOOM MODE</b><br><small>Move hands apart/together</small>";
                    cursorElement.style.display = 'none'; // Hide single cursor to reduce clutter

                    // Get center of palms (Landmark 9 is middle finger knuckle)
                    const h1 = results.multiHandLandmarks[0][9];
                    const h2 = results.multiHandLandmarks[1][9];
                    
                    // Calculate distance
                    const dx = h1.x - h2.x;
                    const dy = h1.y - h2.y;
                    const currentDist = Math.sqrt(dx*dx + dy*dy);

                    if (previousTwoHandDist !== null) {
                        const delta = currentDist - previousTwoHandDist;
                        
                        // Zoom Factor
                        const zoomSpeed = 8.0; 
                        
                        // Get direction camera is looking
                        const viewDir = new THREE.Vector3();
                        camera.getWorldDirection(viewDir);
                        
                        // Move camera along that direction
                        // If delta > 0 (hands moving apart) -> Zoom In (Move forward)
                        // If delta < 0 (hands moving together) -> Zoom Out (Move backward)
                        
                        // Note: Using a small deadzone to prevent jitter
                        if (Math.abs(delta) > 0.005) {
                            camera.position.addScaledVector(viewDir, delta * zoomSpeed);
                        }
                    }
                    
                    previousTwoHandDist = currentDist;
                    
                } else {
                    // --- ONE HAND: ROTATE MODE ---
                    statusElement.innerHTML = "üëã <b>ROTATE MODE</b><br><small>Move hand around</small>";
                    cursorElement.style.display = 'block';
                    previousTwoHandDist = null; // Reset zoom state

                    const landmarks = results.multiHandLandmarks[0];
                    // Tracking Cursor (Index Finger Tip - Landmark 8)
                    const x = 1.0 - landmarks[8].x; // Mirror X
                    const y = landmarks[8].y;

                    // Smoothing
                    handX += (x - handX) * 0.2;
                    handY += (y - handY) * 0.2;

                    cursorElement.style.left = (handX * 100) + '%';
                    cursorElement.style.top = (handY * 100) + '%';
                }

            } else {
                handActive = false;
                statusElement.classList.remove('mode-active');
                statusElement.innerHTML = "Waiting for hands...";
                statusElement.style.color = "#aaa";
                cursorElement.style.display = 'none';
                previousTwoHandDist = null;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, // Enable tracking of two hands
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        let cameraActive = false;
        
        toggleBtn.addEventListener('click', () => {
            if (!cameraActive) {
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                cameraUtils.start();
                videoElement.style.opacity = '0.5';
                statusElement.style.display = 'block';
                toggleBtn.innerText = "Stop Hand Control";
                toggleBtn.classList.add('active');
                cameraActive = true;
            } else {
                location.reload();
            }
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Procedural Animations
            planet.rotation.y += CONFIG.rotationSpeed;
            atmosphere.rotation.y += CONFIG.rotationSpeed;
            rings.rotation.z -= CONFIG.rotationSpeed * 0.5;
            stars.rotation.y -= CONFIG.rotationSpeed * 0.1;
            dust.rotation.y -= CONFIG.rotationSpeed * 0.2;

            // Hand Rotation Control (Single Hand)
            // Zoom is handled directly in onResults for responsiveness
            if (cameraActive && handActive && previousTwoHandDist === null) {
                const sensitivity = 0.05;
                const deadzone = 0.1;

                const dx = handX - 0.5;
                const dy = handY - 0.5;

                if (Math.abs(dx) > deadzone) {
                    const angle = -dx * sensitivity;
                    const x = camera.position.x;
                    const z = camera.position.z;
                    camera.position.x = x * Math.cos(angle) - z * Math.sin(angle);
                    camera.position.z = x * Math.sin(angle) + z * Math.cos(angle);
                }

                if (Math.abs(dy) > deadzone) {
                    camera.position.y += dy * sensitivity * 20;
                }
                
                camera.lookAt(scene.position);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>
